import { Canvas, Meta, Story, ArgsTable } from '@storybook/addon-docs';

import Button, { buttonVariants, buttonSizes } from './Button.vue';

export const buttonStatues = ["default", "active", "focus", "disabled"];

<Meta title="Components/UI/ButtonVue" component={Button} />

# Buttons

Buttons allow users to take actions, and make choices, with a single tap.

## Button tags

Use the button classes on an `<a>`, `<button>`, or `<input>` element.
For more details please refer to [Bootstrap](https://getbootstrap.com/docs/3.4/css/#buttons-tags).

<Canvas withSource="open">
  <Story name="Tags"
    decorators={[
      () => ({
        template: '<div style="display:flex; gap:1em; align-items:center"><story /></div>',
      }),
    ]}
  >
    {() => {
      return {
        components: { "qg-button": Button },
        template: `
          <qg-button is="a" href="#" role="button">Link</qg-button>
          <qg-button type="submit">Button[type=submit]</qg-button>
          <qg-button is="input" type="button" value="Input[type=button]" />
          <qg-button is="input" type="button" value="Input[type=submit]" />
        `,
      };
    }}
  </Story>
</Canvas>

## Options and States

### Options

Use any of the available button classes to quickly create a styled button.
The SWE leverages the button component from Bootstrap, with the addition of the `Secondary` button.

Publishers may choose between dark and light Outline button according to the background colour, light version by using class `.btn-outline-light` and dark version by using class `.btn-outline-dark`

### States

For **active** state, there's no need to add `:active`/ as it's a pseudo-class, but if you need to force the same appearance, go ahead and add `.active`.

For **disabled** state, add the `disabled` attribute to `<button>` buttons or add the `.disabled` class to `<a>` buttons.

For **focus** state, there's no need to add `:focus`/ as it's a pseudo-class, but if you need to force the same appearance, go ahead and add `.focus`.

<Canvas withSource="open">
  <Story name="States"
    decorators={[
      () => ({
        template: `
          <div style="display:grid; grid-template-columns: repeat(4, max-content); justify-items: start; gap: 1em; background-color: lightgrey; padding:1em">
            ${buttonStatues.map(state=>`<div>${state}</div>`).join("")}
            <story />
          </div>`,
      }),
    ]}
  >
    {() => {
      return {
        components: { "qg-button": Button },
        template: buttonVariants.map(
          variant=>buttonStatues.map(
            state=>`
              <qg-button 
                variant="${variant}" 
                ${state==="disabled" ? "disabled" : "" }
                ${state==="focus" ? "isFocus" : "" }
                ${state==="active" ? "isActive" : "" }
              >${variant}</qg-button>`
          ).join("")
        ).join(""),
      };
    }}
  </Story>
</Canvas>

## Sizes

Fancy larger or smaller buttons? Add `.btn-lg`, `.btn-sm`, or `.btn-xs` for additional sizes.

<Canvas withSource="open">
  <Story name="Sizes"
    decorators={[
      () => ({
        template: '<div style="display:flex; gap:1em; align-items:center"><story /></div>',
      }),
    ]}
  >
    {() => {
      return {
        components: { "qg-button": Button },
        template: buttonSizes.map(size=>`<qg-button size="${size}">${size}</qg-button>`).join(""),
      };
    }}
  </Story>
</Canvas>

Create block level buttons—those that span the full width of a parent— by adding `.btn-block`.

<Canvas withSource="open">
  <Story name="BlockSizes">
    {() => {
      return {
        components: { "qg-button": Button },
        template: `
          <qg-button type="button" isBlock>Default</qg-button>
          <qg-button type="button" variant="primary" isBlock>Primary</qg-button>
        `,
      };
    }}
  </Story>
</Canvas>

## Props
<ArgsTable of={Button} />